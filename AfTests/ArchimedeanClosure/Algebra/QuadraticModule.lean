/-
Copyright (c) 2026 AF-Tests Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: AF-Tests Contributors
-/
import AfTests.ArchimedeanClosure.Algebra.FreeStarAlgebra
import Mathlib.Algebra.Order.Module.Defs

/-! # Quadratic Module M

This file defines the quadratic module M for the free *-algebra.

## Main definitions

* `QuadraticModuleGenerators n` - The generating set for M
* `QuadraticModule n` - The quadratic module as a set (carrier for M-positive states)

## Mathematical Background

The quadratic module M consists of finite sums of the form:
  Σ aᵢ* aᵢ + Σ bⱼₖ* gⱼ bⱼₖ

This is equivalently the cone generated by:
  {star a * a | a ∈ A₀} ∪ {star b * gⱼ * b | b ∈ A₀, j ∈ Fin n}
-/

namespace FreeStarAlgebra

variable {n : ℕ}

/-- The set of "squares": elements of the form star a * a. -/
def squareSet (n : ℕ) : Set (FreeStarAlgebra n) :=
  { m | ∃ a : FreeStarAlgebra n, m = star a * a }

/-- The set of "generator-weighted squares": elements of the form star b * gⱼ * b. -/
def generatorWeightedSet (n : ℕ) : Set (FreeStarAlgebra n) :=
  { m | ∃ (j : Fin n) (b : FreeStarAlgebra n), m = star b * generator j * b }

/-- The generating elements for the quadratic module. -/
def QuadraticModuleGenerators (n : ℕ) : Set (FreeStarAlgebra n) :=
  squareSet n ∪ generatorWeightedSet n

/-- Membership in squareSet. -/
theorem mem_squareSet_iff {m : FreeStarAlgebra n} :
    m ∈ squareSet n ↔ ∃ a, m = star a * a := Iff.rfl

/-- star a * a is in squareSet. -/
theorem star_mul_self_mem_squareSet (a : FreeStarAlgebra n) :
    star a * a ∈ squareSet n := ⟨a, rfl⟩

/-- star b * gⱼ * b is in generatorWeightedSet. -/
theorem star_generator_mul_mem_weighted (j : Fin n) (b : FreeStarAlgebra n) :
    star b * generator j * b ∈ generatorWeightedSet n := ⟨j, b, rfl⟩

/-- The quadratic module M as a set: finite sums of generators with nonnegative real coefficients.

This is the carrier set for defining M-positive states. We define it as an inductive
set capturing exactly the closure of generators under addition and nonnegative real scaling.
Since FreeStarAlgebra is now an ℝ-algebra, ℝ-scaling is native.
-/
inductive QuadraticModuleSet (n : ℕ) : Set (FreeStarAlgebra n) where
  | generator_mem : ∀ m ∈ QuadraticModuleGenerators n, QuadraticModuleSet n m
  | add_mem : ∀ m₁ m₂, QuadraticModuleSet n m₁ → QuadraticModuleSet n m₂ →
      QuadraticModuleSet n (m₁ + m₂)
  | smul_mem : ∀ (c : ℝ) (m), 0 ≤ c → QuadraticModuleSet n m →
      QuadraticModuleSet n (c • m)

/-- Abbreviation for the quadratic module. -/
abbrev QuadraticModule (n : ℕ) : Set (FreeStarAlgebra n) := QuadraticModuleSet n

/-- star a * a is in QuadraticModule. -/
theorem star_mul_self_mem (a : FreeStarAlgebra n) :
    star a * a ∈ QuadraticModule n :=
  QuadraticModuleSet.generator_mem _ (Or.inl ⟨a, rfl⟩)

/-- star b * gⱼ * b is in QuadraticModule. -/
theorem star_generator_mul_mem (j : Fin n) (b : FreeStarAlgebra n) :
    star b * generator j * b ∈ QuadraticModule n :=
  QuadraticModuleSet.generator_mem _ (Or.inr ⟨j, b, rfl⟩)

/-- QuadraticModule is closed under addition. -/
theorem QuadraticModule.add_mem {m₁ m₂ : FreeStarAlgebra n}
    (h₁ : m₁ ∈ QuadraticModule n) (h₂ : m₂ ∈ QuadraticModule n) :
    m₁ + m₂ ∈ QuadraticModule n :=
  QuadraticModuleSet.add_mem _ _ h₁ h₂

/-- QuadraticModule is closed under nonnegative ℝ-scaling. -/
theorem QuadraticModule.smul_mem {c : ℝ} (hc : 0 ≤ c) {m : FreeStarAlgebra n}
    (hm : m ∈ QuadraticModule n) :
    c • m ∈ QuadraticModule n :=
  QuadraticModuleSet.smul_mem c m hc hm

/-- QuadraticModule is closed under conjugation: star b * m * b ∈ M for m ∈ M.

This is a key property used in the Archimedean boundedness argument. -/
theorem QuadraticModule.star_mul_mem_star_mul {m : FreeStarAlgebra n}
    (hm : m ∈ QuadraticModule n) (b : FreeStarAlgebra n) :
    star b * m * b ∈ QuadraticModule n := by
  induction hm with
  | generator_mem m hgen =>
    rcases hgen with ⟨a, rfl⟩ | ⟨j, c, rfl⟩
    · -- Case: m = star a * a
      -- star b * (star a * a) * b = star(a*b) * (a*b)
      have h : star b * (star a * a) * b = star (a * b) * (a * b) := by
        simp only [star_mul, mul_assoc]
      rw [h]
      exact star_mul_self_mem (a * b)
    · -- Case: m = star c * g_j * c
      -- star b * (star c * g_j * c) * b = star(c*b) * g_j * (c*b)
      have h : star b * (star c * generator j * c) * b = star (c * b) * generator j * (c * b) := by
        simp only [star_mul, mul_assoc]
      rw [h]
      exact star_generator_mul_mem j (c * b)
  | add_mem m₁ m₂ _ _ ih₁ ih₂ =>
    -- star b * (m₁ + m₂) * b = star b * m₁ * b + star b * m₂ * b
    have h : star b * (m₁ + m₂) * b = star b * m₁ * b + star b * m₂ * b := by
      simp only [mul_add, add_mul]
    rw [h]
    exact QuadraticModule.add_mem ih₁ ih₂
  | smul_mem r m hr _ ih =>
    -- star b * (r • m) * b = r • (star b * m * b)
    have h : star b * (r • m) * b = r • (star b * m * b) := by
      simp only [Algebra.smul_def, mul_assoc, Algebra.commutes]
    rw [h]
    exact QuadraticModule.smul_mem hr ih

end FreeStarAlgebra
