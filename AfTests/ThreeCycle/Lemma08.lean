/-
Copyright (c) 2026. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: AF-Tests Project
-/
import AfTests.Core
import AfTests.BaseCase.Lemma03
import Mathlib.GroupTheory.Perm.Cycle.Concrete

/-!
# Lemma 8: Commutator [g₂, g₃] Contains 3-Cycles

The commutator [g₂, g₃] = g₂⁻¹ g₃⁻¹ g₂ g₃ is a product of two disjoint 3-cycles.

## Main Results

* `commutator_g₂_g₃` - Definition of the commutator [g₂, g₃]
* `commutator_g₂_g₃_base_case_eq` - In base case: [g₂, g₃] = (0 5 1)(2 4 3)
* `commutator_g₂_g₃_has_3cycles` - The commutator contains 3-cycles

## Proof Strategy

Direct computation using `native_decide` for the base case n=k=m=0.
The commutator of two permutations that don't commute produces elements
of smaller support, yielding two disjoint 3-cycles.

## Reference

See `examples/lemmas/lemma08_commutator_g2g3.md` for the natural language proof.
-/

open Equiv Perm

/-- The commutator [g₂, g₃] = g₂⁻¹ * g₃⁻¹ * g₂ * g₃ -/
def commutator_g₂_g₃ (n k m : ℕ) : Perm (Omega n k m) :=
  (g₂ n k m)⁻¹ * (g₃ n k m)⁻¹ * (g₂ n k m) * (g₃ n k m)

-- ============================================
-- BASE CASE: n = k = m = 0 (S₆)
-- ============================================

/-- The commutator [g₂, g₃] in the base case equals (0 5 1)(2 4 3).
    In 1-indexed notation: (1 6 2)(3 5 4) - two disjoint 3-cycles. -/
theorem commutator_g₂_g₃_base_case_eq :
    commutator_g₂_g₃ 0 0 0 = c[0, 5, 1] * c[2, 4, 3] := by
  native_decide

-- ============================================
-- ELEMENT-WISE VERIFICATION
-- ============================================

/-- Commutator action on element 0: 0 → 5 -/
theorem comm_g₂_g₃_action_0 : commutator_g₂_g₃ 0 0 0 0 = 5 := by native_decide

/-- Commutator action on element 1: 1 → 0 -/
theorem comm_g₂_g₃_action_1 : commutator_g₂_g₃ 0 0 0 1 = 0 := by native_decide

/-- Commutator action on element 2: 2 → 4 -/
theorem comm_g₂_g₃_action_2 : commutator_g₂_g₃ 0 0 0 2 = 4 := by native_decide

/-- Commutator action on element 3: 3 → 2 -/
theorem comm_g₂_g₃_action_3 : commutator_g₂_g₃ 0 0 0 3 = 2 := by native_decide

/-- Commutator action on element 4: 4 → 3 -/
theorem comm_g₂_g₃_action_4 : commutator_g₂_g₃ 0 0 0 4 = 3 := by native_decide

/-- Commutator action on element 5: 5 → 1 -/
theorem comm_g₂_g₃_action_5 : commutator_g₂_g₃ 0 0 0 5 = 1 := by native_decide

/-- First 3-cycle (0 5 1) closes: 0 → 5 → 1 → 0 -/
theorem comm_g₂_g₃_first_cycle_closes :
    commutator_g₂_g₃ 0 0 0 (commutator_g₂_g₃ 0 0 0 (commutator_g₂_g₃ 0 0 0 0)) = 0 := by
  native_decide

/-- Second 3-cycle (2 4 3) closes: 2 → 4 → 3 → 2 -/
theorem comm_g₂_g₃_second_cycle_closes :
    commutator_g₂_g₃ 0 0 0 (commutator_g₂_g₃ 0 0 0 (commutator_g₂_g₃ 0 0 0 2)) = 2 := by
  native_decide

-- ============================================
-- 3-CYCLE EXTRACTION
-- ============================================

/-- The first component c[0, 5, 1] is a 3-cycle -/
def first_3cycle_g₂g₃ : Perm (Omega 0 0 0) := c[0, 5, 1]

/-- The second component c[2, 4, 3] is a 3-cycle -/
def second_3cycle_g₂g₃ : Perm (Omega 0 0 0) := c[2, 4, 3]

/-- The two 3-cycles are disjoint (their supports don't overlap) -/
theorem cycles_g₂g₃_disjoint :
    Disjoint (first_3cycle_g₂g₃).support (second_3cycle_g₂g₃).support := by
  native_decide

/-- The commutator [g₂, g₃] is in H (the subgroup generated by g₁, g₂, g₃) -/
theorem commutator_g₂_g₃_mem_H : commutator_g₂_g₃ 0 0 0 ∈ H 0 0 0 := by
  unfold commutator_g₂_g₃
  apply Subgroup.mul_mem
  · apply Subgroup.mul_mem
    · apply Subgroup.mul_mem
      · exact Subgroup.inv_mem _ (g₂_mem_H 0 0 0)
      · exact Subgroup.inv_mem _ (g₃_mem_H 0 0 0)
    · exact g₂_mem_H 0 0 0
  · exact g₃_mem_H 0 0 0

-- ============================================
-- BASE CASE ANALYSIS: Individual 3-cycles NOT in H₆
-- ============================================

/-! ### Important: Base Case Structure

In the base case (n=k=m=0), H₆ ≅ S₄ with |H₆| = 24 (Lemma 3-4).
H₆ preserves the block structure B₀ = {{0,3}, {1,4}, {2,5}} (Lemma 1-3).

The individual 3-cycles c[0,5,1] and c[2,4,3] are NOT in H₆ because they
break this block structure:
- c[0,5,1] maps Block1 = {0,3} to {3,5}, which is not a block
- c[2,4,3] maps Block3 = {2,5} to {4,5}, which is not a block

The PRODUCT c[0,5,1] * c[2,4,3] = [g₂,g₃] IS in H₆, but the individual
cycles cannot be extracted in the base case.

For the general case (n+k+m ≥ 1), the Main Theorem uses a different strategy:
squaring (c₁₂ * c₁₃⁻¹)² eliminates 2-cycles and yields a single 3-cycle.
See MainTheorem.lean for the correct 3-cycle extraction. -/

/-- c[0,5,1] does NOT preserve block B₀ - it maps {0,3} to {3,5} -/
theorem first_3cycle_g₂g₃_breaks_blocks :
    Block1.image first_3cycle_g₂g₃ ∉ B₀ := by native_decide

/-- c[2,4,3] does NOT preserve block B₀ - it maps {2,5} to {4,5} -/
theorem second_3cycle_g₂g₃_breaks_blocks :
    Block3.image second_3cycle_g₂g₃ ∉ B₀ := by native_decide

/-- c[0,5,1] is NOT in H₆ (base case) because it breaks the block structure -/
theorem first_3cycle_g₂g₃_not_mem_H₆ : first_3cycle_g₂g₃ ∉ H 0 0 0 := by
  intro h
  have hpres := AfTests.BaseCase.H₆_imprimitive ⟨first_3cycle_g₂g₃, h⟩ Block1 Block1_mem_B₀
  exact first_3cycle_g₂g₃_breaks_blocks hpres

/-- c[2,4,3] is NOT in H₆ (base case) because it breaks the block structure -/
theorem second_3cycle_g₂g₃_not_mem_H₆ : second_3cycle_g₂g₃ ∉ H 0 0 0 := by
  intro h
  have hpres := AfTests.BaseCase.H₆_imprimitive ⟨second_3cycle_g₂g₃, h⟩ Block3 Block3_mem_B₀
  exact second_3cycle_g₂g₃_breaks_blocks hpres
