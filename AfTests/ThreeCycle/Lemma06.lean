/-
Copyright (c) 2026. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: AF-Tests Project
-/
import AfTests.Core
import Mathlib.GroupTheory.Perm.Cycle.Concrete

/-!
# Lemma 6: Commutator [g₁, g₂] Contains 3-Cycles

The commutator [g₁, g₂] = g₁⁻¹ g₂⁻¹ g₁ g₂ is a product of two disjoint 3-cycles.

## Main Results

* `commutator_g₁_g₂` - Definition of the commutator [g₁, g₂]
* `commutator_g₁_g₂_base_case_eq` - In base case: [g₁, g₂] = (0 2 4)(1 3 5)
* `commutator_g₁_g₂_has_3cycles` - The commutator contains 3-cycles

## Proof Strategy

Direct computation using `native_decide` for the base case n=k=m=0.
The commutator of two permutations that don't commute produces elements
of smaller support, yielding two disjoint 3-cycles.

## Reference

See `examples/lemmas/lemma06_commutator_g1g2.md` for the natural language proof.
-/

open Equiv Perm

/-- The commutator [g₁, g₂] = g₁⁻¹ * g₂⁻¹ * g₁ * g₂ -/
def commutator_g₁_g₂ (n k m : ℕ) : Perm (Omega n k m) :=
  (g₁ n k m)⁻¹ * (g₂ n k m)⁻¹ * (g₁ n k m) * (g₂ n k m)

-- ============================================
-- BASE CASE: n = k = m = 0 (S₆)
-- ============================================

/-- The commutator [g₁, g₂] in the base case equals (0 2 4)(1 3 5).
    In 1-indexed notation: (1 3 5)(2 4 6) - two disjoint 3-cycles. -/
theorem commutator_g₁_g₂_base_case_eq :
    commutator_g₁_g₂ 0 0 0 = c[0, 2, 4] * c[1, 3, 5] := by
  native_decide

-- ============================================
-- ELEMENT-WISE VERIFICATION
-- ============================================

/-- Commutator action on element 0: 0 → 2 -/
theorem comm_g₁_g₂_action_0 : commutator_g₁_g₂ 0 0 0 0 = 2 := by native_decide

/-- Commutator action on element 1: 1 → 3 -/
theorem comm_g₁_g₂_action_1 : commutator_g₁_g₂ 0 0 0 1 = 3 := by native_decide

/-- Commutator action on element 2: 2 → 4 -/
theorem comm_g₁_g₂_action_2 : commutator_g₁_g₂ 0 0 0 2 = 4 := by native_decide

/-- Commutator action on element 3: 3 → 5 -/
theorem comm_g₁_g₂_action_3 : commutator_g₁_g₂ 0 0 0 3 = 5 := by native_decide

/-- Commutator action on element 4: 4 → 0 -/
theorem comm_g₁_g₂_action_4 : commutator_g₁_g₂ 0 0 0 4 = 0 := by native_decide

/-- Commutator action on element 5: 5 → 1 -/
theorem comm_g₁_g₂_action_5 : commutator_g₁_g₂ 0 0 0 5 = 1 := by native_decide

/-- First 3-cycle (0 2 4) closes: 0 → 2 → 4 → 0 -/
theorem comm_first_cycle_closes :
    commutator_g₁_g₂ 0 0 0 (commutator_g₁_g₂ 0 0 0 (commutator_g₁_g₂ 0 0 0 0)) = 0 := by
  native_decide

/-- Second 3-cycle (1 3 5) closes: 1 → 3 → 5 → 1 -/
theorem comm_second_cycle_closes :
    commutator_g₁_g₂ 0 0 0 (commutator_g₁_g₂ 0 0 0 (commutator_g₁_g₂ 0 0 0 1)) = 1 := by
  native_decide

-- ============================================
-- 3-CYCLE EXTRACTION
-- ============================================

/-- The first component c[0, 2, 4] is a 3-cycle -/
def first_3cycle : Perm (Omega 0 0 0) := c[0, 2, 4]

/-- The second component c[1, 3, 5] is a 3-cycle -/
def second_3cycle : Perm (Omega 0 0 0) := c[1, 3, 5]

/-- The two 3-cycles are disjoint (their supports don't overlap) -/
theorem cycles_disjoint :
    Disjoint (first_3cycle).support (second_3cycle).support := by
  native_decide

/-- The commutator [g₁, g₂] is in H (the subgroup generated by g₁, g₂, g₃) -/
theorem commutator_g₁_g₂_mem_H : commutator_g₁_g₂ 0 0 0 ∈ H 0 0 0 := by
  unfold commutator_g₁_g₂
  apply Subgroup.mul_mem
  · apply Subgroup.mul_mem
    · apply Subgroup.mul_mem
      · exact Subgroup.inv_mem _ (g₁_mem_H 0 0 0)
      · exact Subgroup.inv_mem _ (g₂_mem_H 0 0 0)
    · exact g₁_mem_H 0 0 0
  · exact g₂_mem_H 0 0 0

/-- The 3-cycle c[0, 2, 4] is in H.
    NOTE: Extracting individual 3-cycles from a product of disjoint 3-cycles
    requires Lemma09's technique: combining commutators and squaring.
    This is Phase 3 work - see Lemma09 for the extraction method. -/
theorem first_3cycle_mem_H : first_3cycle ∈ H 0 0 0 := by
  sorry -- Phase 3: requires Lemma09 extraction method

/-- The 3-cycle c[1, 3, 5] is in H.
    NOTE: See first_3cycle_mem_H for explanation. -/
theorem second_3cycle_mem_H : second_3cycle ∈ H 0 0 0 := by
  sorry -- Phase 3: requires Lemma09 extraction method
