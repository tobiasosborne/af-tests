/-
Copyright (c) 2026 AF-Tests Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: AF-Tests Contributors
-/
import AfTests.Jordan.Macdonald.FreeAlgebra

/-!
# Free Jordan Algebra on Two Generators

Macdonald Step 5: Define the free Jordan algebra FJ{x,y} as a quotient of the
free nonassociative algebra FA{x,y} by commutativity and the Jordan identity.

## Main definitions

* `JordanCong` - The congruence relation on `FreeNAAlg` generated by commutativity
  and the Jordan identity, closed under all algebra operations
* `FreeJordanAlg` - The free Jordan algebra = `FreeNAAlg / JordanCong`
* `FreeJordanAlg.mk` - The quotient map `FreeNAAlg → FreeJordanAlg`
* `FreeJordanAlg.mul` - Jordan multiplication (commutative, satisfies Jordan identity)
* `FreeJordanAlg.x`, `FreeJordanAlg.y` - The two generators

## Main results

* `FreeJordanAlg.mul_comm` - Multiplication is commutative
* `FreeJordanAlg.jordan_identity` - The Jordan identity `(a∘b)∘a² = a∘(b∘a²)`
* `FreeJordanAlg` has `AddCommGroup` and `Module ℝ` instances
-/

/-- The congruence relation on `FreeNAAlg` that defines the free Jordan algebra.
    Quotienting by this relation enforces commutativity and the Jordan identity,
    with closure under all algebra operations (addition, scalar multiplication,
    multiplication) and equivalence relation axioms. -/
inductive JordanCong : FreeNAAlg → FreeNAAlg → Prop where
  /-- Commutativity: `a * b = b * a` -/
  | comm (a b : FreeNAAlg) :
      JordanCong (FreeNAAlg.mul a b) (FreeNAAlg.mul b a)
  /-- Jordan identity: `(a * b) * a² = a * (b * a²)` -/
  | jordan (a b : FreeNAAlg) :
      JordanCong (FreeNAAlg.mul (FreeNAAlg.mul a b) (FreeNAAlg.mul a a))
                 (FreeNAAlg.mul a (FreeNAAlg.mul b (FreeNAAlg.mul a a)))
  /-- Left addition congruence -/
  | add_left (a b c : FreeNAAlg) : JordanCong a b → JordanCong (a + c) (b + c)
  /-- Right addition congruence -/
  | add_right (a b c : FreeNAAlg) : JordanCong a b → JordanCong (c + a) (c + b)
  /-- Scalar multiplication congruence -/
  | smul_compat (r : ℝ) (a b : FreeNAAlg) :
      JordanCong a b → JordanCong (r • a) (r • b)
  /-- Left multiplication congruence -/
  | mul_left (a b c : FreeNAAlg) : JordanCong a b →
      JordanCong (FreeNAAlg.mul a c) (FreeNAAlg.mul b c)
  /-- Right multiplication congruence -/
  | mul_right (a b c : FreeNAAlg) : JordanCong a b →
      JordanCong (FreeNAAlg.mul c a) (FreeNAAlg.mul c b)
  /-- Reflexivity -/
  | refl (a : FreeNAAlg) : JordanCong a a
  /-- Symmetry -/
  | symm {a b : FreeNAAlg} : JordanCong a b → JordanCong b a
  /-- Transitivity -/
  | trans {a b c : FreeNAAlg} : JordanCong a b → JordanCong b c → JordanCong a c

/-- `JordanCong` as a `Setoid` on `FreeNAAlg`. -/
instance jordanSetoid : Setoid FreeNAAlg where
  r := JordanCong
  iseqv := ⟨JordanCong.refl, JordanCong.symm, JordanCong.trans⟩

/-- The free Jordan algebra on two generators, defined as the quotient of the
    free nonassociative algebra by commutativity and the Jordan identity. -/
def FreeJordanAlg := Quotient jordanSetoid

namespace FreeJordanAlg

/-- The quotient map from the free nonassociative algebra. -/
noncomputable def mk : FreeNAAlg → FreeJordanAlg := Quotient.mk jordanSetoid

theorem mk_eq {a b : FreeNAAlg} (h : JordanCong a b) : mk a = mk b :=
  Quotient.sound h

-- Algebraic operations lifted from FreeNAAlg

noncomputable instance : Zero FreeJordanAlg where
  zero := mk 0

noncomputable instance : One FreeJordanAlg where
  one := mk FreeNAAlg.e

noncomputable instance : Add FreeJordanAlg where
  add := Quotient.map₂ (· + ·) fun a₁ a₂ h₁ b₁ b₂ h₂ =>
    JordanCong.trans (JordanCong.add_left a₁ a₂ b₁ h₁)
      (JordanCong.add_right b₁ b₂ a₂ h₂)

noncomputable instance : Neg FreeJordanAlg where
  neg := Quotient.map (fun a => -a) fun a b h => by
    show JordanCong (-a) (-b)
    have : JordanCong ((-1 : ℝ) • a) ((-1 : ℝ) • b) := JordanCong.smul_compat (-1) a b h
    simp only [neg_one_smul] at this; exact this

noncomputable instance : SMul ℝ FreeJordanAlg where
  smul r := Quotient.map (r • ·) fun a b h => JordanCong.smul_compat r a b h

/-- Jordan multiplication on the free Jordan algebra. -/
noncomputable def mul : FreeJordanAlg → FreeJordanAlg → FreeJordanAlg :=
  Quotient.map₂ FreeNAAlg.mul fun a₁ a₂ h₁ b₁ b₂ h₂ =>
    JordanCong.trans (JordanCong.mul_left a₁ a₂ b₁ h₁)
      (JordanCong.mul_right b₁ b₂ a₂ h₂)

-- Simp lemmas: mk preserves all operations

@[simp] theorem mk_zero : mk 0 = (0 : FreeJordanAlg) := rfl
@[simp] theorem mk_one : mk FreeNAAlg.e = (1 : FreeJordanAlg) := rfl
@[simp] theorem mk_add (a b : FreeNAAlg) : mk (a + b) = mk a + mk b := rfl
@[simp] theorem mk_neg (a : FreeNAAlg) : mk (-a) = -mk a := rfl
@[simp] theorem mk_smul (r : ℝ) (a : FreeNAAlg) : mk (r • a) = r • mk a := rfl
@[simp] theorem mk_mul (a b : FreeNAAlg) :
    mk (FreeNAAlg.mul a b) = mul (mk a) (mk b) := rfl

-- Generators

/-- Generator x of the free Jordan algebra. -/
noncomputable def x : FreeJordanAlg := mk FreeNAAlg.x

/-- Generator y of the free Jordan algebra. -/
noncomputable def y : FreeJordanAlg := mk FreeNAAlg.y

-- AddCommGroup instance

noncomputable instance : AddCommGroup FreeJordanAlg where
  add_assoc a b c := by
    induction a using Quotient.ind; induction b using Quotient.ind
    induction c using Quotient.ind
    show mk _ = mk _; congr 1; exact add_assoc _ _ _
  zero_add a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact zero_add _
  add_zero a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact add_zero _
  add_comm a b := by
    induction a using Quotient.ind; induction b using Quotient.ind
    show mk _ = mk _; congr 1; exact add_comm _ _
  neg_add_cancel a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact neg_add_cancel _
  nsmul := nsmulRec
  zsmul := zsmulRec

-- Module ℝ instance

noncomputable instance : Module ℝ FreeJordanAlg where
  one_smul a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact one_smul ℝ _
  mul_smul r s a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact mul_smul r s _
  smul_zero r := by show mk _ = mk _; congr 1; exact smul_zero r
  smul_add r a b := by
    induction a using Quotient.ind; induction b using Quotient.ind
    show mk _ = mk _; congr 1; exact smul_add r _ _
  zero_smul a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact zero_smul ℝ _
  add_smul r s a := by
    induction a using Quotient.ind; show mk _ = mk _; congr 1; exact add_smul r s _

-- Main theorems

/-- Multiplication in the free Jordan algebra is commutative. -/
theorem mul_comm (a b : FreeJordanAlg) : mul a b = mul b a := by
  induction a using Quotient.ind; induction b using Quotient.ind
  exact Quotient.sound (JordanCong.comm _ _)

/-- The Jordan identity holds: `(a * b) * a² = a * (b * a²)`. -/
theorem jordan_identity (a b : FreeJordanAlg) :
    mul (mul a b) (mul a a) = mul a (mul b (mul a a)) := by
  induction a using Quotient.ind; induction b using Quotient.ind
  exact Quotient.sound (JordanCong.jordan _ _)

/-- The quotient map is surjective. -/
theorem mk_surjective : Function.Surjective mk :=
  Quotient.surjective_Quotient_mk'

end FreeJordanAlg
