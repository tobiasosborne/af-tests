/-
Copyright (c) 2026 AF-Tests Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: AF-Tests Contributors
-/
import AfTests.Jordan.Basic
import AfTests.Jordan.LinearizedJordan
import Mathlib.Data.SetLike.Basic
import Mathlib.LinearAlgebra.BilinearMap
import Mathlib.LinearAlgebra.FiniteDimensional.Defs

/-!
# Jordan Subalgebras

This file defines Jordan subalgebras as subsets closed under the Jordan product.

## Main definitions

* `JordanSubalgebra J` - A subalgebra of a Jordan algebra
* `SetLike` instance for `JordanSubalgebra`
-/

/-- A Jordan subalgebra of `J`. -/
structure JordanSubalgebra (J : Type*) [JordanAlgebra J] where
  carrier : Set J
  jone_mem' : JordanAlgebra.jone ∈ carrier
  jmul_mem' : ∀ ⦃a b⦄, a ∈ carrier → b ∈ carrier → JordanAlgebra.jmul a b ∈ carrier
  add_mem' : ∀ ⦃a b⦄, a ∈ carrier → b ∈ carrier → a + b ∈ carrier
  smul_mem' : ∀ (r : ℝ) ⦃a⦄, a ∈ carrier → r • a ∈ carrier
  neg_mem' : ∀ ⦃a⦄, a ∈ carrier → -a ∈ carrier

namespace JordanSubalgebra

variable {J : Type*} [JordanAlgebra J]

instance : SetLike (JordanSubalgebra J) J where
  coe S := S.carrier
  coe_injective' p q h := by cases p; cases q; congr

@[simp]
theorem mem_carrier {S : JordanSubalgebra J} {x : J} : x ∈ S.carrier ↔ x ∈ S := Iff.rfl

theorem jone_mem (S : JordanSubalgebra J) : JordanAlgebra.jone ∈ S := S.jone_mem'

theorem jmul_mem (S : JordanSubalgebra J) {a b : J} (ha : a ∈ S) (hb : b ∈ S) :
    JordanAlgebra.jmul a b ∈ S := S.jmul_mem' ha hb

theorem add_mem (S : JordanSubalgebra J) {a b : J} (ha : a ∈ S) (hb : b ∈ S) :
    a + b ∈ S := S.add_mem' ha hb

theorem smul_mem (S : JordanSubalgebra J) (r : ℝ) {a : J} (ha : a ∈ S) :
    r • a ∈ S := S.smul_mem' r ha

theorem neg_mem (S : JordanSubalgebra J) {a : J} (ha : a ∈ S) :
    -a ∈ S := S.neg_mem' ha

theorem zero_mem (S : JordanSubalgebra J) : (0 : J) ∈ S := by
  have h := S.smul_mem 0 (S.jone_mem)
  simp at h
  exact h

theorem sub_mem (S : JordanSubalgebra J) {a b : J} (ha : a ∈ S) (hb : b ∈ S) :
    a - b ∈ S := by
  rw [sub_eq_add_neg]
  exact S.add_mem ha (S.neg_mem hb)

/-- The subalgebra as an AddSubgroup. -/
def toAddSubgroup (S : JordanSubalgebra J) : AddSubgroup J where
  carrier := S.carrier
  add_mem' := fun ha hb => S.add_mem' ha hb
  zero_mem' := S.zero_mem
  neg_mem' := fun ha => S.neg_mem' ha

/-- The subalgebra as a Submodule. -/
def toSubmodule (S : JordanSubalgebra J) : Submodule ℝ J where
  carrier := S.carrier
  add_mem' := fun ha hb => S.add_mem' ha hb
  zero_mem' := S.zero_mem
  smul_mem' := fun r _ ha => S.smul_mem' r ha

end JordanSubalgebra

/-! ### Generated Subalgebra

The subalgebra C(a) generated by a single element a consists of all "polynomials" in a,
i.e., linear combinations of powers a^n. This subalgebra is commutative and associative
(by power-associativity). -/

namespace JordanAlgebra

variable {J : Type*} [JordanAlgebra J]

/-- The power submodule: span of {1, a, a², ...}. -/
def powerSubmodule (a : J) : Submodule ℝ J :=
  Submodule.span ℝ (Set.range (jpow a))

theorem jpow_mem_powerSubmodule' (a : J) (n : ℕ) : jpow a n ∈ powerSubmodule a :=
  Submodule.subset_span ⟨n, rfl⟩

/-- The Jordan product as a bilinear map. -/
def jmulBilin : J →ₗ[ℝ] J →ₗ[ℝ] J where
  toFun a := L a
  map_add' a b := by ext; simp only [L_apply, add_jmul, LinearMap.add_apply]
  map_smul' r a := by ext x; simp only [L_apply, LinearMap.smul_apply, RingHom.id_apply, jmul_smul]

@[simp]
theorem jmulBilin_apply (x y : J) : jmulBilin x y = jmul x y := rfl

/-- Power submodule is closed under jmul. Uses bilinear map span lemma. -/
theorem powerSubmodule_jmul_closed' (a : J) {x y : J}
    (hx : x ∈ powerSubmodule a) (hy : y ∈ powerSubmodule a) :
    jmul x y ∈ powerSubmodule a := by
  have hbasis : ∀ u ∈ Set.range (jpow a), ∀ v ∈ Set.range (jpow a),
      jmulBilin u v ∈ powerSubmodule a := by
    intro u hu v hv
    obtain ⟨m, hm⟩ := hu
    obtain ⟨n, hn⟩ := hv
    simp only [← hm, ← hn, jmulBilin_apply, jpow_add]
    exact jpow_mem_powerSubmodule' a (m + n)
  exact LinearMap.BilinMap.apply_apply_mem_of_mem_span (powerSubmodule a)
    (Set.range (jpow a)) (Set.range (jpow a)) jmulBilin hbasis x y hx hy

/-- The subalgebra generated by a single element. C(a) = span{1, a, a², ...}. -/
def generatedSubalgebra (a : J) : JordanSubalgebra J where
  carrier := powerSubmodule a
  jone_mem' := by
    change jone ∈ powerSubmodule a
    have h : jone = jpow a 0 := (jpow_zero a).symm
    rw [h]; exact jpow_mem_powerSubmodule' a 0
  jmul_mem' := fun {x y} hx hy => powerSubmodule_jmul_closed' a hx hy
  add_mem' := fun {a' b} ha hb => Submodule.add_mem _ ha hb
  smul_mem' := fun r {a'} ha => Submodule.smul_mem _ r ha
  neg_mem' := fun {a'} ha => Submodule.neg_mem _ ha

theorem mem_generatedSubalgebra_iff (a x : J) :
    x ∈ generatedSubalgebra a ↔ x ∈ powerSubmodule a := Iff.rfl

theorem jpow_mem_generatedSubalgebra (a : J) (n : ℕ) :
    jpow a n ∈ generatedSubalgebra a := jpow_mem_powerSubmodule' a n

theorem self_mem_generatedSubalgebra (b : J) : b ∈ generatedSubalgebra b := by
  convert jpow_mem_generatedSubalgebra b 1 using 1
  exact (jpow_one b).symm

/-- The generated subalgebra C(a) is finite-dimensional when J is finite-dimensional.
    This is because C(a) is a submodule of the finite-dimensional space J. -/
instance generatedSubalgebra_finiteDimensional [FiniteDimensional ℝ J] (a : J) :
    FiniteDimensional ℝ (generatedSubalgebra a).toSubmodule :=
  FiniteDimensional.finiteDimensional_submodule _

/-- Powers of a associate: (a^m ∘ a^n) ∘ a^k = a^m ∘ (a^n ∘ a^k).
    This follows directly from jpow_add. -/
theorem jpow_jmul_assoc (a : J) (m n k : ℕ) :
    jmul (jmul (jpow a m) (jpow a n)) (jpow a k) =
    jmul (jpow a m) (jmul (jpow a n) (jpow a k)) := by
  rw [jpow_add, jpow_add, jpow_add, jpow_add]
  ring_nf  -- m + n + k = m + (n + k)

/-- The Jordan product is associative within C(a).
    This is because C(a) consists of polynomials in a single element. -/
theorem generatedSubalgebra_jmul_assoc (a : J) {x y z : J}
    (hx : x ∈ generatedSubalgebra a) (hy : y ∈ generatedSubalgebra a)
    (hz : z ∈ generatedSubalgebra a) :
    jmul (jmul x y) z = jmul x (jmul y z) := by
  rw [mem_generatedSubalgebra_iff] at hx hy hz
  -- Induction on z ∈ span{powers}
  induction hz using Submodule.span_induction with
  | mem p hp =>
    obtain ⟨k, hk⟩ := hp
    subst hk
    -- Induction on y ∈ span{powers}
    induction hy using Submodule.span_induction with
    | mem q hq =>
      obtain ⟨n, hn⟩ := hq
      subst hn
      -- Induction on x ∈ span{powers}
      induction hx using Submodule.span_induction with
      | mem r hr =>
        obtain ⟨m, hm⟩ := hr
        subst hm
        exact jpow_jmul_assoc a m n k
      | zero => simp only [zero_jmul]
      | add s t _ _ ihs iht => simp only [add_jmul, ihs, iht]
      | smul r s _ ihs => simp only [jmul_smul, ihs]
    | zero => simp only [zero_jmul, jmul_zero]
    | add s t _ _ ihs iht => simp only [add_jmul, jmul_add, ihs, iht]
    | smul r s _ ihs => simp only [smul_jmul, jmul_smul, ihs]
  | zero => simp only [jmul_zero]
  | add s t _ _ ihs iht => rw [jmul_add, jmul_add, ihs, iht, ← jmul_add]
  | smul r s _ ihs => simp only [smul_jmul, ihs]

end JordanAlgebra
