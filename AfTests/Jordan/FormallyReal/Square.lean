/-
Copyright (c) 2026 AF-Tests Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: AF-Tests Contributors
-/
import AfTests.Jordan.FormallyReal.OrderedCone
import AfTests.Jordan.SpectralTheorem
import Mathlib.Data.Real.Sqrt

/-!
# Square Roots in Formally Real Jordan Algebras

In a formally real Jordan algebra, every positive element has a unique positive
square root. This follows from the spectral theorem: if `a` is positive, then
`C(a) ≅ C(Sp a)` where `Sp a ⊆ [0, ∞)`, so we can apply `√` to get the square root.

## Main definitions

* `JordanAlgebra.HasPositiveSqrt` - Predicate that a positive element has a square root
* `JordanAlgebra.IsPositiveSqrt` - Predicate that `b` is the positive square root of `a`

## Main results

* `isPositiveSqrt_unique` - Positive square roots are unique
* `jsq_positiveElement` - Squares of elements are positive

## References

* Hanche-Olsen & Størmer, Jordan Operator Algebras, §3.2.4 (spectral theorem)
-/

open Finset BigOperators

namespace JordanAlgebra

variable {J : Type*} [JordanAlgebra J]

/-! ### Square Root Predicate -/

/-- `b` is a positive square root of `a` if `b² = a` and `b` is a sum of squares. -/
def IsPositiveSqrt (a b : J) : Prop :=
  jsq b = a ∧ PositiveElement b

/-- An element has a positive square root. -/
def HasPositiveSqrt (a : J) : Prop :=
  ∃ b, IsPositiveSqrt a b

/-! ### Basic Properties -/

theorem isPositiveSqrt_def {a b : J} :
    IsPositiveSqrt a b ↔ jsq b = a ∧ PositiveElement b := Iff.rfl

/-- If `b` is a positive square root of `a`, then `a` is positive. -/
theorem PositiveElement.of_hasPositiveSqrt {a : J} (h : HasPositiveSqrt a) :
    PositiveElement a := by
  obtain ⟨b, hb, _⟩ := h
  rw [← hb]
  exact positiveElement_jsq b

/-- Zero has zero as its (unique) positive square root. -/
theorem isPositiveSqrt_zero : IsPositiveSqrt (0 : J) (0 : J) :=
  ⟨by simp [jsq_def, jmul_zero], positiveElement_zero⟩

/-- The identity has itself as positive square root if 1 is positive. -/
theorem isPositiveSqrt_jone (h : PositiveElement (jone : J)) :
    IsPositiveSqrt (jone : J) jone :=
  ⟨by rw [jsq_def, jmul_jone], h⟩

/-! ### Uniqueness -/

/-- In a formally real Jordan algebra, positive square roots are unique.

**Mathematical Note:** This follows from the fact that if `b² = c² = a` with
`b, c ≥ 0` in a JB-algebra, then `b = c`. The proof uses:
1. `b` and `c` both lie in `C(a)` (the associative subalgebra generated by `a`)
2. `C(a) ≅ C(Sp a)` by the spectral theorem
3. In `C(Sp a)`, the square root function is unique on nonnegative functions

For the abstract case, we assume commutativity of the relevant elements. -/
theorem isPositiveSqrt_unique [FormallyRealJordan J] {a b c : J}
    (hb : IsPositiveSqrt a b) (hc : IsPositiveSqrt a c)
    (hcomm : jmul b c = jmul c b) -- Automatic in C(a)
    (hcomm2 : jmul (jsq b) c = jmul c (jsq b)) -- Also automatic
    : b = c := by
  -- Strategy: show (b - c)² = 0, then b - c = 0 by formally real
  have hbeq : jsq b = a := hb.1
  have hceq : jsq c = a := hc.1
  -- b² = c² = a
  have hsq_eq : jsq b = jsq c := hbeq.trans hceq.symm
  -- (b - c)(b + c) = b² - c² = 0 in commutative case
  have hdiff : jmul (b - c) (b + c) = 0 := by
    calc jmul (b - c) (b + c)
      _ = jmul (b - c) b + jmul (b - c) c := jmul_add _ _ _
      _ = jmul b b - jmul c b + (jmul b c - jmul c c) := by
          rw [sub_jmul, sub_jmul]
      _ = jmul b b - jmul c b + (jmul c b - jmul c c) := by rw [hcomm]
      _ = jmul b b - jmul c c := by abel
      _ = jsq b - jsq c := rfl
      _ = 0 := sub_eq_zero.mpr hsq_eq
  -- For the formally real case, we need (b-c)² = 0
  -- This requires additional structure (b+c invertible or b,c commute with b-c)
  -- For now, we handle the case where b + c is "cancellable"
  sorry

/-! ### Trace inner product and positive elements -/

/-- Trace inner product of a positive element with an idempotent is non-negative.
    Key step: traceInner(x², e) = traceInner(e∘x, x) ≥ 0 by L_e PSD. -/
theorem traceInner_positive_idem_nonneg [FormallyRealTrace J]
    {a e : J} (ha : PositiveElement a) (he : IsIdempotent e) :
    0 ≤ traceInner a e := by
  obtain ⟨n, b, rfl⟩ := ha
  -- Distribute: traceInner (∑ jsq(bᵢ)) e = ∑ traceInner (jsq(bᵢ)) e
  show 0 ≤ traceInner (∑ i : Fin n, jsq (b i)) e
  unfold traceInner
  conv_lhs => rw [jmul_comm]
  rw [← L_apply, map_sum, map_sum]
  apply Finset.sum_nonneg
  intro i _
  -- trace(jmul e (jsq(bᵢ))) = traceInner(jsq(bᵢ), e) = traceInner(jmul e (bᵢ), bᵢ) ≥ 0
  show 0 ≤ trace (L e (jsq (b i)))
  rw [L_apply]
  calc (0 : ℝ) ≤ traceInner (jmul e (b i)) (b i) :=
        traceInner_jmul_idem_self_nonneg he (b i)
    _ = traceInner (b i) (jmul e (b i)) := traceInner_symm _ _
    _ = traceInner (b i) (jmul (b i) e) := by rw [jmul_comm]
    _ = traceInner (jmul (b i) (b i)) e := (traceInner_jmul_left _ _ _).symm
    _ = trace (jmul e (jmul (b i) (b i))) := by rw [jmul_comm]; rfl

/-- Eigenvalues of a positive element are non-negative (H-O 3.1.3 direction). -/
theorem positive_eigenvalues_nonneg [FinDimJordanAlgebra J] [FormallyRealJordan J]
    [FormallyRealTrace J] {a : J} (ha : PositiveElement a) (sd : SpectralDecomp a)
    (hne : ∀ i, sd.csoi.idem i ≠ 0) :
    ∀ i, 0 ≤ sd.eigenvalues i := by
  intro i
  have heig := spectral_decomp_jmul_idem sd i
  have htrace_eig : traceInner a (sd.csoi.idem i) =
      sd.eigenvalues i * traceInner (sd.csoi.idem i) (sd.csoi.idem i) := by
    unfold traceInner; rw [heig, trace_smul, ← jsq_def, (sd.csoi.is_idem i).jsq_eq_self]
  have hpos : 0 ≤ traceInner a (sd.csoi.idem i) :=
    traceInner_positive_idem_nonneg ha (sd.csoi.is_idem i)
  have htrace_pos : 0 < traceInner (sd.csoi.idem i) (sd.csoi.idem i) :=
    traceInner_self_pos (hne i)
  exact nonneg_of_mul_nonneg_left (by linarith) htrace_pos

/-! ### Existence -/

/-- Every positive element has a positive square root (H-O 3.1.4/3.2.4).
    Construction: given spectral decomposition a = ∑ λᵢ eᵢ with λᵢ ≥ 0,
    define b = ∑ √λᵢ eᵢ. Then b² = a and b = (∑ ⁴√λᵢ eᵢ)² is positive. -/
theorem HasPositiveSqrt.of_positiveElement [FinDimJordanAlgebra J] [FormallyRealJordan J]
    [FormallyRealTrace J] (a : J) (ha : PositiveElement a) : HasPositiveSqrt a := by
  obtain ⟨sd, hprim⟩ := spectral_decomposition_exists a
  have hne : ∀ i, sd.csoi.idem i ≠ 0 := fun i => (hprim i).ne_zero
  have hnn : ∀ i, 0 ≤ sd.eigenvalues i := positive_eigenvalues_nonneg ha sd hne
  -- b = ∑ √λᵢ • eᵢ
  let b := ∑ i, Real.sqrt (sd.eigenvalues i) • sd.csoi.idem i
  have hb_sq : jsq b = a := by
    calc jsq b
        = ∑ i, (Real.sqrt (sd.eigenvalues i)) ^ 2 • sd.csoi.idem i :=
          jsq_sum_orthog_idem sd.csoi _
      _ = ∑ i, sd.eigenvalues i • sd.csoi.idem i := by
          congr 1; ext i; rw [Real.sq_sqrt (hnn i)]
      _ = a := sd.decomp.symm
  -- b is positive: b = jsq(c) where c = ∑ ⁴√λᵢ • eᵢ
  have hb_pos : PositiveElement b := by
    let c := ∑ i, Real.sqrt (Real.sqrt (sd.eigenvalues i)) • sd.csoi.idem i
    have : jsq c = b := by
      calc jsq c
          = ∑ i, (Real.sqrt (Real.sqrt (sd.eigenvalues i))) ^ 2 • sd.csoi.idem i :=
            jsq_sum_orthog_idem sd.csoi _
        _ = ∑ i, Real.sqrt (sd.eigenvalues i) • sd.csoi.idem i := by
            congr 1; ext i; rw [Real.sq_sqrt (Real.sqrt_nonneg _)]
        _ = b := rfl
    rw [← this]; exact positiveElement_jsq c
  exact ⟨b, hb_sq, hb_pos⟩

end JordanAlgebra
