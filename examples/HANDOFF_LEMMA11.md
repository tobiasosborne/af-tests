# Handoff: Proving Lemma 11 (Primitivity of H)

## Overview

This document provides detailed guidance for proving Lemma 11 and its sub-lemmas (11.1–11.5) using the `af` (Adversarial Proof Framework) tool.

**Master Reference:** See `./proof_master.md` for the complete proof structure:
- Lemma 11: lines 318–324
- Lemma 11.1: lines 328–341
- Lemma 11.2: lines 345–365
- Lemma 11.3: lines 369–381
- Lemma 11.4: lines 385–399
- Lemma 11.5: lines 403–467+

---

## Lemma 11 Structure

Lemma 11 is decomposed into sub-lemmas that must be proven in order:

| Lemma | Location | Statement | Dependencies |
|-------|----------|-----------|--------------|
| **11.1** | `lemma11_1_unique_block_system/` | The only non-trivial block system for H₆ on {1,...,6} is B₀ | Lemma 1 |
| **11.2** | `lemma11_2_cycle_fixing_block/` | Cycle σ with σ(B)=B implies supp(σ)⊆B or supp(σ)∩B=∅ | None |
| **11.3** | `lemma11_3_tail_in_block/` | If g₁(B)=B for block B containing a₁, then supp(g₁)⊆B | Lemma 11.2 |
| **11.4** | `lemma11_4_block_orbit/` | For σ-invariant block system, r∣ℓ and \|B∩supp(σ)\|=ℓ/r | None |
| **11.5** | `lemma11_5_no_nontrivial_blocks/` | If n+k+m≥1, then H admits no non-trivial block system | Lemmas 11.1–11.4 |
| **11** | `lemma11_primitivity/` | If n+k+m≥1, then H acts primitively on Ω | Lemmas 5, 10, 11.5 |

**Recommended proof order:** 11.2 → 11.1 → 11.3 → 11.4 → 11.5 → 11

---

## Proof Chain So Far

The following lemmas have been validated and provide the foundation:

| Lemma | Statement | Status |
|-------|-----------|--------|
| **Lemma 1** | B₀ = {{1,4}, {2,5}, {3,6}} is preserved setwise by h₁, h₂, h₃ | VALIDATED |
| **Lemma 2** | φ: H₆ → S_{B₀} satisfies Im(φ) = S₃ | VALIDATED |
| **Lemma 3** | H₆ ≅ S₄, acting imprimitively on {1,...,6} | VALIDATED |
| **Lemma 4** | \|H₆\| = 24 < 360 = \|A₆\|, hence H₆ ∉ {A₆, S₆} | VALIDATED |
| **Lemma 5** | H = ⟨g₁, g₂, g₃⟩ acts transitively on Ω | VALIDATED |
| **Lemma 9** | (c₁₂ · c₁₃⁻¹)² = (1 6 2), a 3-cycle in H | VALIDATED |
| **Lemma 10** | Primitivity criterion: G primitive ⟺ no non-trivial partitions ⟺ stabilizers maximal | VALIDATED |

---

## Key Definitions to Add

Before proving any lemma, add the relevant definitions using `af def-add`. Here are the essential definitions for Lemma 11:

### Global Definitions (add to each lemma directory as needed)

```bash
# Domain and generators
af def-add Omega "Omega := {1, 2, 3, 4, 5, 6, a_1, ..., a_n, b_1, ..., b_k, c_1, ..., c_m} with |Omega| = N = 6 + n + k + m."

af def-add Core "Core := {1, 2, 3, 4, 5, 6}, the base 6 elements."

af def-add g_1 "g_1 := (1 6 4 3 a_1 ... a_n), a (4+n)-cycle. In base case (n=0): h_1 = (1 6 4 3)."

af def-add g_2 "g_2 := (1 2 4 5 b_1 ... b_k), a (4+k)-cycle. In base case (k=0): h_2 = (1 2 4 5)."

af def-add g_3 "g_3 := (5 6 2 3 c_1 ... c_m), a (4+m)-cycle. In base case (m=0): h_3 = (5 6 2 3)."

af def-add H "H := <g_1, g_2, g_3>, the group generated by the three cycles."

af def-add H_6 "H_6 := <h_1, h_2, h_3> where h_i are the base case generators (n=k=m=0). We have H_6 ≅ S_4."

# Block system definitions
af def-add Block "A subset B ⊆ Omega is a block for G if for all g ∈ G, either g(B) = B or g(B) ∩ B = ∅."

af def-add Block_System "A block system is a partition of Omega into blocks. Trivial: {Omega} or {{x} : x ∈ Omega}."

af def-add B_0 "B_0 := {{1,4}, {2,5}, {3,6}}, the unique non-trivial block system for H_6 on {1,...,6}."

af def-add Support "For permutation σ, supp(σ) := {x : σ(x) ≠ x}, the set of points moved by σ."

# Cycle properties
af def-add Cycle_Definition "A permutation σ is a cycle if it has exactly one non-trivial orbit. An ℓ-cycle moves exactly ℓ points."

af def-add Cycle_Orbit_Action "For σ = (x_1 x_2 ... x_ℓ), we have σ(x_i) = x_{i+1 mod ℓ}. The orbit is {x_1, ..., x_ℓ} = supp(σ)."
```

---

## Lemma 11.1: Unique Block System in Base Case

**Statement:** The only non-trivial block system for H₆ on {1,...,6} is B₀ = {{1,4}, {2,5}, {3,6}}.

**Location:** `./lemmas/lemma11_1_unique_block_system/`

**Dependencies:** Lemma 1 (B₀ is preserved by h₁, h₂, h₃)

### Proof Strategy

1. Block sizes must divide 6, so |B| ∈ {2, 3}
2. Enumerate all partitions into blocks of size 2 (there are 15)
3. Check each against preservation by h₁, h₂, h₃ — only B₀ survives
4. Enumerate all partitions into blocks of size 3 (there are 10)
5. Check each — none are preserved

### Step-by-Step Commands

```bash
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_1_unique_block_system
af status

# Claim and add definitions
af claim 1 --owner prover-1 --role prover

af def-add H_6 "H_6 := <h_1, h_2, h_3> where h_1=(1 6 4 3), h_2=(1 2 4 5), h_3=(5 6 2 3). We have H_6 ≅ S_4."
af def-add B_0 "B_0 := {{1,4}, {2,5}, {3,6}}, a partition of {1,...,6} into 2-element blocks."
af def-add Block_System "A block system is a G-invariant partition. Non-trivial means neither all singletons nor the whole set."
af def-add Block_Size_Divisibility "For a transitive group on n points, block sizes must divide n."

# Add proof structure
af refine 1 --owner prover-1 -s "OVERVIEW: Block sizes must divide 6, giving |B| ∈ {2, 3}. We enumerate all partitions and check H_6-invariance."

af refine 1.1 --owner prover-1 --sibling -s "CASE |B|=2: There are C(6,2)·C(4,2)·C(2,2)/3! = 15·3·1/6 = 15 partitions into 3 blocks of size 2."

af refine 1.2 --owner prover-1 --sibling -s "SIZE-2 ENUMERATION: The 15 partitions are: {{1,2},{3,4},{5,6}}, {{1,2},{3,5},{4,6}}, {{1,2},{3,6},{4,5}}, {{1,3},{2,4},{5,6}}, {{1,3},{2,5},{4,6}}, {{1,3},{2,6},{4,5}}, {{1,4},{2,3},{5,6}}, {{1,4},{2,5},{3,6}}, {{1,4},{2,6},{3,5}}, {{1,5},{2,3},{4,6}}, {{1,5},{2,4},{3,6}}, {{1,5},{2,6},{3,4}}, {{1,6},{2,3},{4,5}}, {{1,6},{2,4},{3,5}}, {{1,6},{2,5},{3,4}}."

af refine 1.3 --owner prover-1 --sibling -s "SIZE-2 CHECK: h_1=(1 6 4 3) maps {1,4}→{6,3}={3,6}, {2,5}→{2,5}, {3,6}→{4,1}={1,4}. Only B_0={{1,4},{2,5},{3,6}} is invariant under all h_i (verified by Lemma 1)."

af refine 1.4 --owner prover-1 --sibling -s "CASE |B|=3: There are C(6,3)/2 = 20/2 = 10 partitions into 2 blocks of size 3."

af refine 1.5 --owner prover-1 --sibling -s "SIZE-3 ENUMERATION: The 10 partitions are: {{1,2,3},{4,5,6}}, {{1,2,4},{3,5,6}}, {{1,2,5},{3,4,6}}, {{1,2,6},{3,4,5}}, {{1,3,4},{2,5,6}}, {{1,3,5},{2,4,6}}, {{1,3,6},{2,4,5}}, {{1,4,5},{2,3,6}}, {{1,4,6},{2,3,5}}, {{1,5,6},{2,3,4}}."

af refine 1.6 --owner prover-1 --sibling -s "SIZE-3 CHECK: For each partition, verify h_1, h_2, h_3 do not all preserve it. Example: {{1,2,3},{4,5,6}} under h_1=(1 6 4 3): h_1({1,2,3})={6,2,4}∉{{1,2,3},{4,5,6}}. All 10 fail. QED."

af release 1 --owner prover-1
af status
```

---

## Lemma 11.2: Cycle Fixing Block Setwise

**Statement:** Let σ ∈ Sₙ be a cycle. Let B ⊆ {1,...,n} with σ(B) = B. Then either supp(σ) ⊆ B or supp(σ) ∩ B = ∅.

**Location:** `./lemmas/lemma11_2_cycle_fixing_block/`

**Dependencies:** None (fundamental property of cycles)

### Proof Strategy

This is a key lemma about cycles and blocks. The proof uses induction along the cycle.

1. Let σ = (x₁ x₂ ... xₗ) be an ℓ-cycle
2. Suppose supp(σ) ∩ B ≠ ∅. Pick xᵢ ∈ B ∩ supp(σ)
3. Since σ(B) = B, we have σ(xᵢ) = xᵢ₊₁ ∈ B
4. By induction, all xⱼ ∈ B
5. Hence supp(σ) ⊆ B

### Step-by-Step Commands

```bash
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_2_cycle_fixing_block
af status

af claim 1 --owner prover-1 --role prover

af def-add Cycle_Definition "A permutation σ is a cycle if it has exactly one non-trivial orbit. Written σ = (x_1 x_2 ... x_ℓ)."
af def-add Support "supp(σ) := {x : σ(x) ≠ x}. For cycle σ = (x_1 ... x_ℓ), supp(σ) = {x_1, ..., x_ℓ}."
af def-add Cycle_Action "For σ = (x_1 x_2 ... x_ℓ), we have σ(x_i) = x_{i+1} where indices are mod ℓ."
af def-add Setwise_Stabilizer "σ(B) = B means σ maps B to itself setwise: x ∈ B ⟹ σ(x) ∈ B."

af refine 1 --owner prover-1 -s "OVERVIEW: Let σ = (x_1 x_2 ... x_ℓ). We show: if supp(σ) ∩ B ≠ ∅, then supp(σ) ⊆ B."

af refine 1.1 --owner prover-1 --sibling -s "SETUP: Assume supp(σ) ∩ B ≠ ∅. Pick x_i ∈ B ∩ supp(σ) for some i ∈ {1,...,ℓ}."

af refine 1.2 --owner prover-1 --sibling -s "INDUCTION BASE: x_i ∈ B by assumption."

af refine 1.3 --owner prover-1 --sibling -s "INDUCTION STEP: Suppose x_j ∈ B for some j. Since σ(B) = B and x_j ∈ B, we have σ(x_j) = x_{j+1} ∈ B."

af refine 1.4 --owner prover-1 --sibling -s "INDUCTION CONCLUSION: By induction, x_{i+1}, x_{i+2}, ..., x_{i+ℓ-1} ∈ B. Since indices are mod ℓ, this covers all of {x_1, ..., x_ℓ} = supp(σ)."

af refine 1.5 --owner prover-1 --sibling -s "CONCLUSION: supp(σ) ⊆ B. The contrapositive gives: supp(σ) ∩ B = ∅ or supp(σ) ⊆ B. QED."

af release 1 --owner prover-1
af status
```

---

## Lemma 11.3: Tail Point in Block Implies Support in Block

**Statement:** Suppose n ≥ 1 and H preserves a block system B on Ω. Let B be the block containing a₁. If g₁(B) = B, then supp(g₁) ⊆ B.

**Location:** `./lemmas/lemma11_3_tail_in_block/`

**Dependencies:** Lemma 11.2

### Proof Strategy

This is a direct application of Lemma 11.2:
1. g₁ = (1 6 4 3 a₁ ... aₙ) is a cycle
2. a₁ ∈ B ∩ supp(g₁) ≠ ∅
3. By Lemma 11.2, supp(g₁) ⊆ B

### Step-by-Step Commands

```bash
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_3_tail_in_block
af status

af claim 1 --owner prover-1 --role prover

af def-add g_1 "g_1 := (1 6 4 3 a_1 ... a_n), a (4+n)-cycle with supp(g_1) = {1, 6, 4, 3, a_1, ..., a_n}."
af def-add Lemma_11_2 "Lemma 11.2: For cycle σ with σ(B) = B, either supp(σ) ⊆ B or supp(σ) ∩ B = ∅."

af refine 1 --owner prover-1 -s "OVERVIEW: Direct application of Lemma 11.2 to the cycle g_1."

af refine 1.1 --owner prover-1 --sibling -s "PREMISE: n ≥ 1, so a_1 exists. Let B be the block containing a_1. Assume g_1(B) = B."

af refine 1.2 --owner prover-1 --sibling -s "CYCLE CHECK: g_1 = (1 6 4 3 a_1 ... a_n) is a (4+n)-cycle, hence a cycle in the sense of Lemma 11.2."

af refine 1.3 --owner prover-1 --sibling -s "INTERSECTION: a_1 ∈ B (by definition of B) and a_1 ∈ supp(g_1). Thus supp(g_1) ∩ B ≠ ∅."

af refine 1.4 --owner prover-1 --sibling -s "APPLICATION OF LEMMA 11.2: Since g_1(B) = B and supp(g_1) ∩ B ≠ ∅, by Lemma 11.2, supp(g_1) ⊆ B. QED."

af release 1 --owner prover-1
af status
```

---

## Lemma 11.4: Block Orbit Under Single Generator

**Statement:** Let σ ∈ Sₙ be an ℓ-cycle and B a σ-invariant block system with block size d. Let B ∈ B with B ∩ supp(σ) ≠ ∅. Let r be the size of the ⟨σ⟩-orbit of B in B. Then r | ℓ and |B ∩ supp(σ)| = ℓ/r.

**Location:** `./lemmas/lemma11_4_block_orbit/`

**Dependencies:** None

### Proof Strategy

1. σ permutes the blocks in B
2. The orbit of B under ⟨σ⟩ has size r dividing |⟨σ⟩| = ℓ
3. The support of σ is partitioned into r blocks (those in the orbit)
4. Each block contains ℓ/r elements of supp(σ)

### Step-by-Step Commands

```bash
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_4_block_orbit
af status

af claim 1 --owner prover-1 --role prover

af def-add Cycle_Order "For an ℓ-cycle σ, |⟨σ⟩| = ℓ."
af def-add Orbit_Stabilizer "For group G acting on set X, |G| = |Orb(x)| · |Stab(x)|. Hence |Orb(x)| divides |G|."
af def-add Block_Orbit "σ permutes blocks: if B is a block and σ(B) = B', then B' is also a block."

af refine 1 --owner prover-1 -s "OVERVIEW: The cycle σ permutes blocks. The orbit size r divides ℓ = |⟨σ⟩|, and supp(σ) is evenly distributed."

af refine 1.1 --owner prover-1 --sibling -s "BLOCK PERMUTATION: Since B is σ-invariant (σ(B) = B for all B ∈ B), σ induces a permutation of B."

af refine 1.2 --owner prover-1 --sibling -s "ORBIT SIZE: The ⟨σ⟩-orbit of B has size r. By Orbit-Stabilizer, r divides |⟨σ⟩| = ℓ."

af refine 1.3 --owner prover-1 --sibling -s "SUPPORT PARTITION: supp(σ) is a single orbit of σ (as σ is a cycle). This orbit is partitioned into the blocks it intersects."

af refine 1.4 --owner prover-1 --sibling -s "COUNTING: The r blocks in the ⟨σ⟩-orbit of B partition supp(σ). By symmetry (σ cyclically permutes these blocks), each contains ℓ/r elements. QED."

af release 1 --owner prover-1
af status
```

---

## Lemma 11.5: No Non-Trivial Block System for n+k+m ≥ 1

**Statement:** If n + k + m ≥ 1, then H admits no non-trivial block system on Ω.

**Location:** `./lemmas/lemma11_5_no_nontrivial_blocks/`

**Dependencies:** Lemmas 11.1, 11.2, 11.3, 11.4

### Proof Strategy

This is the most complex sub-lemma. The proof is by contradiction with case analysis.

1. Assume B is a non-trivial H-invariant block system with block size d (1 < d < N)
2. WLOG assume n ≥ 1. Let B be the block containing a₁
3. **Case 1:** g₁(B) = B
   - By Lemma 11.3, supp(g₁) ⊆ B, so {1, 3, 4, 6, a₁, ..., aₙ} ⊆ B
   - Analyze g₂ and g₃ similarly, leading to B = Ω (contradiction)
4. **Case 2:** g₁(B) ≠ B
   - The orbit of B under ⟨g₁⟩ has size r > 1
   - Use Lemma 11.4 to derive constraints on block size
   - Show these constraints are impossible

### Step-by-Step Commands

```bash
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_5_no_nontrivial_blocks
af status

af claim 1 --owner prover-1 --role prover

# Add all relevant definitions
af def-add Omega "Omega := {1,...,6, a_1,...,a_n, b_1,...,b_k, c_1,...,c_m} with |Omega| = N = 6+n+k+m."
af def-add g_1 "g_1 := (1 6 4 3 a_1 ... a_n), supp(g_1) = {1, 3, 4, 6, a_1, ..., a_n}."
af def-add g_2 "g_2 := (1 2 4 5 b_1 ... b_k), supp(g_2) = {1, 2, 4, 5, b_1, ..., b_k}."
af def-add g_3 "g_3 := (5 6 2 3 c_1 ... c_m), supp(g_3) = {2, 3, 5, 6, c_1, ..., c_m}."
af def-add Lemma_11_2 "For cycle σ with σ(B) = B: supp(σ) ⊆ B or supp(σ) ∩ B = ∅."
af def-add Lemma_11_3 "If g_1(B) = B for block B ∋ a_1, then supp(g_1) ⊆ B."
af def-add Lemma_11_4 "For σ an ℓ-cycle with B ∩ supp(σ) ≠ ∅ and orbit size r: r | ℓ and |B ∩ supp(σ)| = ℓ/r."

# Proof structure
af refine 1 --owner prover-1 -s "OVERVIEW: Proof by contradiction. Assume non-trivial block system B exists. WLOG n ≥ 1. Let B be the block containing a_1."

af refine 1.1 --owner prover-1 --sibling -s "CASE 1: g_1(B) = B. By Lemma 11.3, supp(g_1) = {1,3,4,6,a_1,...,a_n} ⊆ B."

af refine 1.2 --owner prover-1 --sibling -s "CASE 1 CONTINUED: Since 1,4 ∈ B and g_2 moves both, consider g_2(B). If g_2(B) = B, then supp(g_2) ⊆ B by Lemma 11.2, giving {1,2,4,5,b_1,...,b_k} ⊆ B."

af refine 1.3 --owner prover-1 --sibling -s "CASE 1 SUBCASE g_2(B)=B: Now B ⊇ {1,2,3,4,5,6,a_1,...,a_n,b_1,...,b_k}. Similarly g_3: if g_3(B)=B then supp(g_3) ⊆ B, giving B = Ω. Contradiction (block is trivial)."

af refine 1.4 --owner prover-1 --sibling -s "CASE 1 SUBCASE g_2(B)≠B: g_2(B) ≠ B means 2,5 ∈ g_2(B) (since g_2(1)=2, g_2(4)=5). Continue case analysis with g_3..."

af refine 1.5 --owner prover-1 --sibling -s "CASE 2: g_1(B) ≠ B. The orbit of B under ⟨g_1⟩ has size r > 1. By Lemma 11.4, r | (4+n) and |B ∩ supp(g_1)| = (4+n)/r."

af refine 1.6 --owner prover-1 --sibling -s "CASE 2 ANALYSIS: Since a_1 ∈ B ∩ supp(g_1), we have (4+n)/r ≥ 1. Combined with constraints from g_2, g_3, derive contradiction on block size d."

af refine 1.7 --owner prover-1 --sibling -s "CONCLUSION: All cases lead to contradiction. Hence no non-trivial block system exists when n+k+m ≥ 1. QED."

af release 1 --owner prover-1
af status
```

---

## Lemma 11: Primitivity of H

**Statement:** If n + k + m ≥ 1, then H acts primitively on Ω.

**Location:** `./lemmas/lemma11_primitivity/`

**Dependencies:** Lemmas 5, 10, 11.5

### Proof Strategy

This follows directly from Lemmas 10 and 11.5:
1. By Lemma 5, H is transitive on Ω
2. By Lemma 11.5, H admits no non-trivial block system
3. By Lemma 10 (condition (2) ⟹ condition (1)), H is primitive

### Step-by-Step Commands

```bash
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_primitivity
af status

af claim 1 --owner prover-1 --role prover

af def-add Lemma_5 "Lemma 5: H = ⟨g_1, g_2, g_3⟩ acts transitively on Ω."
af def-add Lemma_10 "Lemma 10: For transitive G, the following are equivalent: (1) G is primitive, (2) G preserves no non-trivial partition, (3) stabilizers are maximal."
af def-add Lemma_11_5 "Lemma 11.5: If n+k+m ≥ 1, then H admits no non-trivial block system on Ω."

af refine 1 --owner prover-1 -s "OVERVIEW: Direct application of Lemma 10 using Lemmas 5 and 11.5."

af refine 1.1 --owner prover-1 --sibling -s "TRANSITIVITY: By Lemma 5, H acts transitively on Ω."

af refine 1.2 --owner prover-1 --sibling -s "NO NON-TRIVIAL BLOCKS: By Lemma 11.5, H preserves no non-trivial block system (= no non-trivial partition)."

af refine 1.3 --owner prover-1 --sibling -s "PRIMITIVITY CRITERION: By Lemma 10 (condition (2) ⟹ (1)), since H is transitive and preserves no non-trivial partition, H is primitive. QED."

af release 1 --owner prover-1
af status
```

---

## Spawning Parallel Verifier Agents

For each lemma, spawn 2-3 parallel verifier agents to check different parts. Example for Lemma 11.2:

```python
# In Claude Code, use Task tool with subagent_type="general-purpose"

# Verifier 1: Check nodes 1.1, 1.2
Task(
    description="Verify setup and base case",
    prompt="You are VERIFIER-1 for Lemma 11.2. Navigate to lemma11_2_cycle_fixing_block and verify nodes 1.1, 1.2...",
    subagent_type="general-purpose"
)

# Verifier 2: Check nodes 1.3, 1.4, 1.5
Task(
    description="Verify induction and conclusion",
    prompt="You are VERIFIER-2 for Lemma 11.2. Navigate to lemma11_2_cycle_fixing_block and verify nodes 1.3, 1.4, 1.5...",
    subagent_type="general-purpose"
)

# Final Verifier: Accept root node
Task(
    description="Final verification",
    prompt="You are FINAL-VERIFIER for Lemma 11.2. Accept the root node after all child nodes are validated...",
    subagent_type="general-purpose"
)
```

---

## af Command Quick Reference

```bash
# Status and inspection
af status                    # View proof tree
af defs                      # List all definitions
af def <name>                # View specific definition
af challenges                # List all challenges

# Adding definitions
af def-add <name> "<content>"

# Prover workflow
af claim <node> --owner <id> --role prover
af amend <node> --owner <id> --statement "<new statement>"
af refine <node> --owner <id> -s "<statement>"
af refine <node> --owner <id> --sibling -s "<statement>"
af release <node> --owner <id>

# Verifier workflow
af claim <node> --owner <id> --role verifier
af challenge <node> --owner <id> --target <target> --severity <severity> --reason "<reason>"
af accept <node> --agent <id> [--confirm]
af release <node> --owner <id>

# Challenge resolution
af resolve-challenge <challenge-id> --owner <id> --response "<response>"

# Challenge targets: statement, inference, dependencies, gap, domain, scope, context, type_error, completeness
# Challenge severities: critical (blocks), major (blocks), minor, note
```

---

## Lessons Learned from Previous Lemmas

1. **Add definitions FIRST** — Before any proof work, add all necessary definitions using `af def-add`

2. **Spawn parallel verifier agents** — Use `Task` tool with `subagent_type="general-purpose"` to spawn multiple pedantic verifiers

3. **Show ALL computation steps** — Especially for case analysis, enumerate all cases explicitly

4. **Amend root claims when needed** — Use `af amend` to fix incorrect initial statements

5. **Challenges are good** — Pedantic verifiers catching gaps (like in Lemma 10 node 1.6) improves proof quality

6. **Reference previous lemmas explicitly** — Add definitions like `Lemma_11_2` that cite the statement

7. **For equivalences, use cyclic proof** — Lemma 10 showed (1)⟹(2)⟹(3)⟹(1) is cleaner than direct equivalences

---

## Checklist Before Starting Each Lemma

- [ ] Navigate to the correct lemma directory
- [ ] Run `af status` to see current state
- [ ] Run `af defs` to check existing definitions
- [ ] Add ALL required definitions using `af def-add`
- [ ] Claim root node as prover
- [ ] Create proof structure with `af refine`
- [ ] Release the root node
- [ ] Spawn parallel verifier agents
- [ ] Resolve any challenges raised
- [ ] Have final verifier accept root node
- [ ] Verify all nodes are `validated` and `clean`

---

## Context and References

- **Master document:** `./proof_master.md` (complete proof structure)
- **Previous handoffs:** `./HANDOFF_LEMMA09.md`
- **Validated lemmas:** 1-5, 7-10 (Lemma 6 refuted original claim but correct value verified)
- **This handoff:** `./HANDOFF_LEMMA11.md`

---

Good luck! The adversarial framework will catch errors, so focus on clarity, completeness, and explicit reasoning.
