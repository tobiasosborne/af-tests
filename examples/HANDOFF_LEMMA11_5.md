# Handoff: Proving Lemma 11.5 (No Non-Trivial Block System)

## Overview

This document provides detailed guidance for proving Lemma 11.5 using the `af` (Adversarial Proof Framework) tool.

**Master Reference:** See `./proof_master.md` for the complete proof structure:
- Lemma 11.5: lines 403â€“489

---

## Lemma 11.5 Statement

**If n + k + m >= 1, then H admits no non-trivial block system on Omega.**

**Location:** `./lemmas/lemma11_5_no_nontrivial_blocks/`

**Dependencies:** Lemmas 11.1, 11.2, 11.3, 11.4 (ALL NOW VALIDATED)

---

## Previously Validated Lemmas (Available as Dependencies)

All four prerequisite lemmas have been validated with the adversarial framework:

| Lemma | Statement | Status | Key Result |
|-------|-----------|--------|------------|
| **11.1** | Unique block system for H_6 | VALIDATED | B_0 = {{1,4}, {2,5}, {3,6}} is the only non-trivial block system for H_6 |
| **11.2** | Cycle fixing block setwise | VALIDATED | For cycle sigma with sigma(B) = B: supp(sigma) in B OR supp(sigma) disjoint from B |
| **11.3** | Tail in block implies support in block | VALIDATED | If g_1(B) = B for block B containing a_1, then supp(g_1) in B |
| **11.4** | Block orbit under single generator | VALIDATED | For sigma an l-cycle with orbit size r: r divides l AND \|B intersect supp(sigma)\| = l/r |

---

## How to Add Definitions

Before proving, add all necessary definitions using `af def-add`. The syntax is:

```bash
af def-add <name> "<content>"
```

### Required Definitions for Lemma 11.5

```bash
# Navigate to the lemma directory first
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_5_no_nontrivial_blocks

# Domain and generators
af def-add Omega "Omega := {1, 2, 3, 4, 5, 6, a_1, ..., a_n, b_1, ..., b_k, c_1, ..., c_m} with |Omega| = N = 6 + n + k + m."

af def-add g_1 "g_1 := (1 6 4 3 a_1 ... a_n), a (4+n)-cycle. supp(g_1) = {1, 3, 4, 6, a_1, ..., a_n}."

af def-add g_2 "g_2 := (1 2 4 5 b_1 ... b_k), a (4+k)-cycle. supp(g_2) = {1, 2, 4, 5, b_1, ..., b_k}."

af def-add g_3 "g_3 := (5 6 2 3 c_1 ... c_m), a (4+m)-cycle. supp(g_3) = {2, 3, 5, 6, c_1, ..., c_m}."

af def-add H "H := <g_1, g_2, g_3>, the group generated by the three cycles acting on Omega."

# Block system definitions
af def-add Block_System "A block system B is a partition of Omega into blocks. Non-trivial means 1 < |B| < N for each block B."

af def-add Block "A subset B of Omega is a block for H if for all h in H: h(B) = B or h(B) disjoint from B."

af def-add Support "supp(sigma) := {x : sigma(x) != x}. For an l-cycle, |supp(sigma)| = l."

# Previous lemmas as axioms
af def-add Lemma_11_1 "Lemma 11.1: The only non-trivial block system for H_6 on {1,...,6} is B_0 = {{1,4}, {2,5}, {3,6}}."

af def-add Lemma_11_2 "Lemma 11.2: For cycle sigma with sigma(B) = B, either supp(sigma) is contained in B or supp(sigma) is disjoint from B."

af def-add Lemma_11_3 "Lemma 11.3: If n >= 1 and g_1(B) = B for block B containing a_1, then supp(g_1) is contained in B."

af def-add Lemma_11_4 "Lemma 11.4: For sigma an l-cycle with B intersect supp(sigma) nonempty and orbit size r: r divides l and |B intersect supp(sigma)| = l/r."
```

---

## Proof Strategy (from proof_master.md)

The proof is by **contradiction with case analysis**:

1. Assume B is a non-trivial H-invariant block system with block size d (1 < d < N)
2. WLOG assume n >= 1. Let B be the block containing a_1

### Case 1: g_1(B) = B

By Lemma 11.3, supp(g_1) = {1, 3, 4, 6, a_1, ..., a_n} is contained in B.

In particular, 1, 4 are in B.

**Sub-case 1a: g_2(B) = B**
- By Lemma 11.2, supp(g_2) is contained in B (since 1 in B intersect supp(g_2))
- So {1, 2, 4, 5, b_1, ..., b_k} is contained in B
- Now B contains {1, 2, 3, 4, 5, 6, a_1, ..., a_n, b_1, ..., b_k}
- Apply same argument to g_3: if g_3(B) = B, then B = Omega (contradiction)
- If g_3(B) != B, use Lemma 11.4 to derive contradiction on block size

**Sub-case 1b: g_2(B) != B**
- Then g_2(B) is a different block containing {2, 5}
- Track images under g_3 to show B eventually equals Omega

### Case 2: g_1(B) != B

- The orbit of B under <g_1> has size r > 1 with r dividing (4+n)
- By Lemma 11.4, |B intersect supp(g_1)| = (4+n)/r
- Analyze how g_2 interacts with the g_1-orbit structure
- Show this forces d = 1 or d = N (contradiction)

---

## Recommended Proof Structure

```bash
# Claim and build proof
af claim 1 --owner prover-1 --role prover

af refine 1 --owner prover-1 -s "OVERVIEW: Proof by contradiction. Assume non-trivial block system B with block size d (1 < d < N). WLOG n >= 1. Let B be the block containing a_1. We analyze cases based on whether g_1(B) = B."

af refine 1.1 --owner prover-1 --sibling -s "CASE 1: g_1(B) = B. By Lemma 11.3, supp(g_1) = {1, 3, 4, 6, a_1, ..., a_n} is contained in B. In particular, 1, 4 are in B."

af refine 1.2 --owner prover-1 --sibling -s "CASE 1a: g_1(B) = B AND g_2(B) = B. Since 1 in B intersect supp(g_2) and g_2(B) = B, by Lemma 11.2, supp(g_2) = {1, 2, 4, 5, b_1, ..., b_k} is contained in B."

af refine 1.3 --owner prover-1 --sibling -s "CASE 1a CONTINUED: Now B contains {1, 2, 3, 4, 5, 6, a_1, ..., a_n, b_1, ..., b_k}. Consider g_3: {2, 3, 5, 6} is contained in B intersect supp(g_3)."

af refine 1.4 --owner prover-1 --sibling -s "CASE 1a SUB-CASE g_3(B) = B: By Lemma 11.2, supp(g_3) is contained in B, so B = Omega. Contradiction (block is trivial)."

af refine 1.5 --owner prover-1 --sibling -s "CASE 1a SUB-CASE g_3(B) != B: Orbit size r > 1 with r dividing (4+m). By Lemma 11.4, |B intersect supp(g_3)| = (4+m)/r. But |{2,3,5,6}| = 4 <= |B intersect supp(g_3)|, so (4+m)/r >= 4, giving r <= 1 + m/4."

af refine 1.6 --owner prover-1 --sibling -s "CASE 1a ANALYSIS: For m <= 3, r <= 1 + 3/4 < 2, so r = 1. Contradiction. For m >= 4, need detailed analysis of r = 2 case leading to contradiction."

af refine 1.7 --owner prover-1 --sibling -s "CASE 1b: g_1(B) = B AND g_2(B) != B. Then g_2(B) is a different block. g_2(1) = 2, g_2(4) = 5, so {2, 5} is contained in g_2(B). Also {3, 6} is contained in B (from supp(g_1))."

af refine 1.8 --owner prover-1 --sibling -s "CASE 1b ANALYSIS: Track g_3 action on B and g_2(B). Since g_3 moves elements in both blocks, the orbit structure forces B to grow until B = Omega."

af refine 1.9 --owner prover-1 --sibling -s "CASE 2: g_1(B) != B. Orbit size r > 1 with r dividing (4+n). By Lemma 11.4, |B intersect supp(g_1)| = (4+n)/r >= 1 (since a_1 in B)."

af refine 1.10 --owner prover-1 --sibling -s "CASE 2 ANALYSIS: The orbit {B, g_1(B), ..., g_1^{r-1}(B)} partitions supp(g_1). Point 1 is in some g_1^j(B). Analyze g_2 interaction: if 1 and 4 in same block, apply Case 1 to that block. If different blocks, g_2 intertwines orbits, forcing d = 1 or d = N."

af refine 1.11 --owner prover-1 --sibling -s "CONCLUSION: All cases lead to contradiction. Hence no non-trivial block system exists when n + k + m >= 1. QED."

af release 1 --owner prover-1
```

---

## Spawning Parallel Verifier Agents

For maximum rigor, spawn one verifier per node. Example:

```python
# In Claude Code, use Task tool with subagent_type="general-purpose"

# Spawn verifiers in parallel for each node
Task(
    description="Verifier for node 1.1",
    prompt="You are VERIFIER-1 for Lemma 11.5. Verify node 1.1 only. Working directory: /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_5_no_nontrivial_blocks. Claim with: af claim 1.1 --owner verifier-1 --role verifier. Check the Case 1 setup is correct. Accept with: af accept 1.1 --agent verifier-1 --confirm. Release with: af release 1.1 --owner verifier-1.",
    subagent_type="general-purpose"
)
# ... repeat for each node
```

---

## af Command Quick Reference

```bash
# Status and inspection
af status                    # View proof tree
af defs                      # List all definitions
af def <name>                # View specific definition
af challenges                # List all challenges

# Adding definitions
af def-add <name> "<content>"

# Prover workflow
af claim <node> --owner <id> --role prover
af amend <node> --owner <id> --statement "<new statement>"
af refine <node> --owner <id> -s "<statement>"
af refine <node> --owner <id> --sibling -s "<statement>"
af release <node> --owner <id>

# Verifier workflow
af claim <node> --owner <id> --role verifier
af challenge <node> --owner <id> --target <target> --severity <severity> --reason "<reason>"
af accept <node> --agent <id> [--confirm]
af release <node> --owner <id>

# Challenge targets: statement, inference, dependencies, gap, domain, scope, context, type_error, completeness
# Challenge severities: critical (blocks), major (blocks), minor, note
```

---

## Lessons Learned from Lemmas 11.1-11.4

1. **Add ALL definitions first** - Before any proof work, add all necessary definitions
2. **Spawn parallel verifier agents** - One per node for maximum rigor (8 verifiers for 8 nodes)
3. **Be explicit about bidirectional claims** - Node 1.5 in Lemma 11.4 was challenged for claiming "exactly" without proving the converse
4. **Show computation steps** - Verifiers caught arithmetic errors in Lemma 11.1 (C(4,2) = 6, not 3)
5. **Reference previous lemmas explicitly** - Add Lemma_11_X definitions to cite validated results
6. **Challenges improve quality** - Don't fear challenges; they make the proof stronger

---

## Complexity Warning

Lemma 11.5 is the most complex sub-lemma with extensive case analysis. Consider:

1. **Breaking into more nodes** - The proof has multiple nested cases
2. **Using sub-proofs** - Each case can be its own mini-proof
3. **Careful tracking** - Keep track of what's in B at each step

The key insight is that the generators g_1, g_2, g_3 have overlapping supports on the core {1,2,3,4,5,6}, which forces any non-trivial block to eventually contain everything.

---

## Checklist Before Starting

- [ ] Navigate to `/home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_5_no_nontrivial_blocks`
- [ ] Run `af status` to see current state (should be 1 pending node)
- [ ] Run `af defs` to check existing definitions (should be none)
- [ ] Add ALL required definitions using `af def-add`
- [ ] Claim root node as prover
- [ ] Create proof structure with `af refine` (recommend 10-12 nodes for case analysis)
- [ ] Release the root node
- [ ] Spawn parallel verifier agents (one per node)
- [ ] Resolve any challenges raised
- [ ] Have final verifier accept root node
- [ ] Verify all nodes are `validated` and `clean`

---

## References

- **Master document:** `./proof_master.md` (lines 403-489 for Lemma 11.5)
- **Previous handoff:** `./HANDOFF_LEMMA11.md` (general Lemma 11 structure)
- **Validated lemmas:** 11.1, 11.2, 11.3, 11.4 in `./lemmas/lemma11_X_*/`

Good luck! The adversarial framework will catch errors, so focus on clarity, completeness, and explicit reasoning in each case.
