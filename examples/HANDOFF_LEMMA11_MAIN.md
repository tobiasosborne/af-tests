# Handoff: Proving Lemma 11 (Primitivity of H)

## Overview

This document provides detailed guidance for proving **Lemma 11** (the main primitivity lemma) using the `af` (Adversarial Proof Framework) tool.

**Master Reference:** See `./proof_master.md` for the complete proof structure:
- Lemma 11: lines 318–324
- Lemma 11.1–11.5: lines 328–489

---

## Lemma 11 Statement

**If n + k + m >= 1, then H acts primitively on Omega.**

**Location:** `./lemmas/lemma11_primitivity/`

**Current Status:** 1 pending node (root claim ready for proof)

---

## All Sub-Lemmas Are NOW VALIDATED

All five prerequisite lemmas have been validated with the adversarial framework:

| Lemma | Statement | Status | Key Technique |
|-------|-----------|--------|---------------|
| **11.1** | Unique block system for H₆ is B₀ = {{1,4}, {2,5}, {3,6}} | ✅ VALIDATED | Enumeration of all 25 partitions |
| **11.2** | Cycle σ with σ(B) = B ⟹ supp(σ) ⊆ B or supp(σ) ∩ B = ∅ | ✅ VALIDATED | Induction along cycle |
| **11.3** | If g₁(B) = B for block B containing a₁, then supp(g₁) ⊆ B | ✅ VALIDATED | Direct application of 11.2 |
| **11.4** | For σ-invariant block system, r \| ℓ and \|B ∩ supp(σ)\| = ℓ/r | ✅ VALIDATED | Orbit-stabilizer + symmetry |
| **11.5** | If n + k + m >= 1, H admits no non-trivial block system | ✅ VALIDATED | Fixed-point arguments |

### Other Required Dependencies

| Lemma | Statement | Status |
|-------|-----------|--------|
| **Lemma 5** | H acts transitively on Ω | ✅ VALIDATED |
| **Lemma 10** | Primitivity criterion: G primitive ⟺ no non-trivial partition | ✅ VALIDATED |

---

## Proof Strategy

Lemma 11 follows **directly** from combining Lemmas 5, 10, and 11.5:

1. **Transitivity (Lemma 5):** H = ⟨g₁, g₂, g₃⟩ acts transitively on Ω
2. **No non-trivial blocks (Lemma 11.5):** H admits no non-trivial block system when n + k + m ≥ 1
3. **Primitivity criterion (Lemma 10):** For transitive G, primitivity ⟺ no non-trivial partition
4. **Conclusion:** By Lemma 10, since H is transitive (Lemma 5) and preserves no non-trivial partition (Lemma 11.5), H is primitive

This is a **simple 3-node proof** that chains the dependencies.

---

## How to Add Definitions

Before proving, add all necessary definitions using `af def-add`. The syntax is:

```bash
af def-add <name> "<content>"
```

### Required Definitions for Lemma 11

```bash
# Navigate to the lemma directory first
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_primitivity

# Check current state
af status
af defs

# Add the three key dependency lemmas as definitions
af def-add Lemma_5 "Lemma 5: H = <g_1, g_2, g_3> acts transitively on Omega. (VALIDATED)"

af def-add Lemma_10 "Lemma 10: For transitive group G on set X, the following are equivalent: (1) G is primitive, (2) G preserves no non-trivial partition of X, (3) point stabilizers are maximal subgroups. (VALIDATED)"

af def-add Lemma_11_5 "Lemma 11.5: If n + k + m >= 1, then H admits no non-trivial block system on Omega. (VALIDATED via fixed-point arguments)"

# Add domain definitions for context
af def-add Omega "Omega := {1, 2, 3, 4, 5, 6, a_1, ..., a_n, b_1, ..., b_k, c_1, ..., c_m} with |Omega| = N = 6 + n + k + m."

af def-add H "H := <g_1, g_2, g_3>, the group generated by the three (4+tail)-cycles acting on Omega."

af def-add Primitive_Action "A transitive group action is primitive if the only G-invariant partitions are trivial (all singletons or whole set)."
```

---

## Step-by-Step Proof Commands

```bash
# Navigate to the lemma directory
cd /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_primitivity

# Check current state
af status

# Add definitions (as shown above)
af def-add Lemma_5 "Lemma 5: H = <g_1, g_2, g_3> acts transitively on Omega. (VALIDATED)"
af def-add Lemma_10 "Lemma 10: For transitive group G on set X, the following are equivalent: (1) G is primitive, (2) G preserves no non-trivial partition of X, (3) point stabilizers are maximal subgroups. (VALIDATED)"
af def-add Lemma_11_5 "Lemma 11.5: If n + k + m >= 1, then H admits no non-trivial block system on Omega. (VALIDATED)"
af def-add Omega "Omega := {1,...,6, a_1,...,a_n, b_1,...,b_k, c_1,...,c_m} with |Omega| = N = 6 + n + k + m."
af def-add H "H := <g_1, g_2, g_3>, the group generated by the three (4+tail)-cycles."
af def-add Primitive_Action "A transitive group action is primitive iff the only G-invariant partitions are trivial."

# Claim root node as prover
af claim 1 --owner prover-1 --role prover

# Build proof structure - this is a simple 3-step proof
af refine 1 --owner prover-1 -s "OVERVIEW: Direct application of Lemmas 5, 10, and 11.5 to establish primitivity."

af refine 1.1 --owner prover-1 --sibling -s "TRANSITIVITY: By Lemma 5, the group H = <g_1, g_2, g_3> acts transitively on Omega. This is established via the connectivity of the support graph."

af refine 1.2 --owner prover-1 --sibling -s "NO NON-TRIVIAL BLOCKS: By Lemma 11.5, when n + k + m >= 1, the group H admits no non-trivial block system on Omega. This was proven via fixed-point arguments showing any assumed block B eventually equals Omega."

af refine 1.3 --owner prover-1 --sibling -s "PRIMITIVITY CRITERION: By Lemma 10 (equivalence (2) implies (1)): A transitive group is primitive if and only if it preserves no non-trivial partition. Since H is transitive (node 1.1) and preserves no non-trivial partition (node 1.2), H is primitive. QED."

# Release the root node
af release 1 --owner prover-1

# Check status
af status
```

---

## Spawning Verifier Agents

For maximum rigor, spawn parallel verifier agents. This proof is simple (3 nodes), so 2 verifiers suffice:

### Verifier 1: Check nodes 1.1 and 1.2

```
You are VERIFIER-1 for Lemma 11 (Primitivity). Verify nodes 1.1 and 1.2 with EXTREME RIGOR.

Working directory: /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_primitivity

WORKFLOW:
1. Run `af status` and `af defs` to see current state
2. For node 1.1: `af claim 1.1 --owner verifier-1 --role verifier`
3. Check: Does it correctly cite Lemma 5? Is transitivity established?
4. If SATISFIED: `af accept 1.1 --agent verifier-1 --confirm` then `af release 1.1 --owner verifier-1`
5. Repeat for node 1.2 - check it correctly cites Lemma 11.5

CRITICAL: Demand that references to validated lemmas are accurate. Challenge if the statement misrepresents the lemma.
```

### Verifier 2 (Final): Check node 1.3 and root

```
You are VERIFIER-FINAL for Lemma 11 (Primitivity). Verify node 1.3 and the root node.

Working directory: /home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_primitivity

WORKFLOW:
1. Wait for nodes 1.1 and 1.2 to be validated
2. For node 1.3: `af claim 1.3 --owner verifier-final --role verifier`
3. Check: Does it correctly apply Lemma 10? Is the implication (2) ⟹ (1) valid?
4. Accept if correct: `af accept 1.3 --agent verifier-final --confirm`
5. Then claim and verify root: `af claim 1 --owner verifier-final --role verifier`
6. Accept root: `af accept 1 --agent verifier-final --confirm`
7. Release: `af release 1 --owner verifier-final`

Report final `af status` showing all nodes validated and clean.
```

---

## af Command Quick Reference

```bash
# Status and inspection
af status                    # View proof tree
af defs                      # List all definitions
af def <name>                # View specific definition
af challenges                # List all challenges

# Adding definitions
af def-add <name> "<content>"

# Prover workflow
af claim <node> --owner <id> --role prover
af amend <node> --owner <id> --statement "<new statement>"
af refine <node> --owner <id> -s "<statement>"
af refine <node> --owner <id> --sibling -s "<statement>"
af release <node> --owner <id>

# Verifier workflow
af claim <node> --owner <id> --role verifier
af challenge <node> --owner <id> --target <target> --severity <severity> --reason "<reason>"
af accept <node> --agent <id> [--confirm]
af release <node> --owner <id>

# Challenge resolution
af resolve-challenge <challenge-id> --owner <id> --explanation "<explanation>"
af archive <node> --reason "<reason>" --yes

# Challenge targets: statement, inference, dependencies, gap, domain, scope, context, type_error, completeness
# Challenge severities: critical (blocks), major (blocks), minor, note
```

---

## Key Lessons from Lemma 11.5 Proof

The validation of Lemma 11.5 (the most complex sub-lemma) revealed important lessons:

### 1. Fixed-Point Arguments are Powerful

The original orbit analysis approach had algebraic errors. The simpler **fixed-point argument** proved more robust:

> If element x is in block B and g fixes x (i.e., g(x) = x), then x ∈ g(B).
> If g(B) ≠ B (disjoint), this gives x ∈ B ∩ g(B), contradiction.

This was used repeatedly:
- **Case 1a-ii:** Elements {1, 4, a_i, b_j} are fixed by g₃, contradicting g₃(B) disjoint from B
- **Case 1b:** Elements {3, 6, a_i} are fixed by g₂, making Case 1b impossible
- **Case 2:** Tail elements {a_i} are fixed by g₂ and g₃, forcing g₂(B) = g₃(B) = B

### 2. WLOG Requires Justification

The assumption "WLOG n ≥ 1" required explicit justification via relabeling:
- Rename (g₁, g₂, g₃) → (g₂, g₁, g₃) if k ≥ 1 instead
- The pairwise intersection pattern |supp(gᵢ) ∩ supp(gⱼ)| = 2 is preserved

### 3. Spawn Independent Verifiers with Extreme Rigor

29 challenges were raised during Lemma 11.5 verification:
- 11 critical (blocked proof)
- All were resolved by amending nodes with fixed-point arguments

### 4. Archive Superseded Nodes

When proof strategy changes (orbit analysis → fixed-point), archive superseded nodes:
```bash
af archive 1.9.2 --reason "Superseded by fixed-point argument" --yes
```

---

## Dependency Graph for Main Theorem

```
Main Theorem (H = A_N or S_N)
├── Lemma 12: Jordan's Theorem (primitive + 3-cycle ⟹ ≥ A_n)
├── Lemma 11: Primitivity ← YOU ARE HERE
│   ├── Lemma 5: Transitivity
│   ├── Lemma 10: Primitivity criterion
│   └── Lemma 11.5: No non-trivial blocks
│       ├── Lemma 11.1: Unique block system for H₆
│       ├── Lemma 11.2: Cycle fixing block
│       ├── Lemma 11.3: Tail in block
│       └── Lemma 11.4: Block orbit size
├── Lemma 9: 3-cycle in H
│   ├── Lemma 6, 7, 8: Commutators
│   └── ...
└── Lemmas 13-15: Parity analysis (A_N vs S_N)
```

---

## Expected Outcome

After completing this proof:

```
=== Proof Status ===

1 [validated/clean] If n + k + m >= 1, then H acts primitively on Omega.
  1.1 [validated/clean] TRANSITIVITY: By Lemma 5...
  1.2 [validated/clean] NO NON-TRIVIAL BLOCKS: By Lemma 11.5...
  1.3 [validated/clean] PRIMITIVITY CRITERION: By Lemma 10...

--- Statistics ---
Nodes: 4 total
  Epistemic: 0 pending, 4 validated
  Taint: 4 clean
```

---

## Checklist Before Starting

- [ ] Navigate to `/home/tobiasosborne/Projects/af-tests/examples/lemmas/lemma11_primitivity`
- [ ] Run `af status` to see current state (should be 1 pending node)
- [ ] Run `af defs` to check existing definitions (may be empty)
- [ ] Add ALL required definitions using `af def-add`
- [ ] Claim root node as prover
- [ ] Create proof structure with `af refine` (3 nodes: transitivity, no blocks, criterion)
- [ ] Release the root node
- [ ] Spawn parallel verifier agents (2 verifiers for this simple proof)
- [ ] Resolve any challenges raised
- [ ] Have final verifier accept root node
- [ ] Verify all nodes are `validated` and `clean`

---

## References

- **Master document:** `./proof_master.md` (lines 318-324 for Lemma 11)
- **Sub-lemma handoff:** `./HANDOFF_LEMMA11.md` (detailed guidance for 11.1-11.5)
- **Lemma 11.5 handoff:** `./HANDOFF_LEMMA11_5.md` (the complex sub-lemma)
- **Validated sub-lemmas:** All in `./lemmas/lemma11_X_*/`

---

## Next Steps After Lemma 11

Once Lemma 11 is validated, the proof chain continues to:

1. **Lemma 12 (Jordan's Theorem):** Admit as axiom - primitive group with 3-cycle contains A_n
2. **Lemmas 13-15 (Parity):** Determine whether H = A_N or S_N based on generator parities
3. **Main Theorem:** Combine all lemmas to prove H = A_N (all odd) or S_N (otherwise)

Good luck! This is a straightforward proof given the validated dependencies.
